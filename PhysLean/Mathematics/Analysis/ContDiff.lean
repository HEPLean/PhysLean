/-
Copyright (c) 2025 Matteo Cipollina. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Matteo Cipollina
-/

import Mathlib.Analysis.Calculus.ContDiff.Operations
import Mathlib.LinearAlgebra.Dual.Lemmas
import Mathlib.LinearAlgebra.FreeModule.PID
import Mathlib.RingTheory.Henselian
import PhysLean.Mathematics.LinearAlgebra.BilinearForm

/-!
# Smoothness (ContDiff) Utilities

This file provides utility lemmas and constructions for working with smooth
functions (`ContDiff`) and continuity in the context of normed and finite-dimensional
vector spaces over a nontrivially normed field.

-/

namespace ContDiff

variable {ùïú X V : Type*} [NontriviallyNormedField ùïú]
variable [NormedAddCommGroup X] [NormedSpace ùïú X]
variable [NormedAddCommGroup V] [NormedSpace ùïú V]
variable {f : X ‚Üí V} {s : Set X} {x‚ÇÄ : X} {n : WithTop ‚Ñï‚àû}

-- First direction: if f is C^n, then œÜ ‚àò f is C^n for any continuous linear functional œÜ
lemma comp_continuous_linear_apply_right
    (hf : ContDiffWithinAt ùïú n f s x‚ÇÄ) (œÜ : V ‚ÜíL[ùïú] ùïú) :
    ContDiffWithinAt ùïú n (œÜ ‚àò f) s x‚ÇÄ :=
  ContDiffWithinAt.comp x‚ÇÄ œÜ.contDiff.contDiffWithinAt hf (Set.mapsTo_univ _ _)

-- Second direction: in finite dimensions, if all projections are C^n, then f is C^n
lemma of_forall_coord [FiniteDimensional ùïú V] [CompleteSpace ùïú]
    (h : ‚àÄ œÜ : V ‚ÜíL[ùïú] ùïú, ContDiffWithinAt ùïú n (œÜ ‚àò f) s x‚ÇÄ) :
    ContDiffWithinAt ùïú n f s x‚ÇÄ := by
  let b := Module.finBasis ùïú V
  let equiv := b.equivFunL
  suffices ContDiffWithinAt ùïú n (equiv ‚àò f) s x‚ÇÄ by
    have hequiv_symm_smooth : ContDiff ùïú ‚ä§ equiv.symm := ContinuousLinearEquiv.contDiff equiv.symm
    have hequiv_symm_smooth_n : ContDiff ùïú n equiv.symm :=
      ContDiff.of_le hequiv_symm_smooth (le_top : n ‚â§ ‚ä§)
    have h_eq : f = equiv.symm ‚àò (equiv ‚àò f) := by
      ext x; simp only [Function.comp_apply, ContinuousLinearEquiv.symm_apply_apply];
    rw [h_eq]
    apply ContDiffWithinAt.comp x‚ÇÄ hequiv_symm_smooth_n.contDiffWithinAt this (Set.mapsTo_univ _ _)
  apply contDiffWithinAt_pi.mpr
  intro i
  let coord_i : V ‚ÜíL[ùïú] ùïú := LinearMap.toContinuousLinearMap (b.coord i)
  exact h coord_i

-- Full bidirectional lemma
lemma iff_forall_coord [FiniteDimensional ùïú V] [CompleteSpace ùïú] :
    ContDiffWithinAt ùïú n f s x‚ÇÄ ‚Üî
    ‚àÄ œÜ : V ‚ÜíL[ùïú] ùïú, ContDiffWithinAt ùïú n (œÜ ‚àò f) s x‚ÇÄ := by
  constructor
  ¬∑ exact comp_continuous_linear_apply_right
  ¬∑ exact of_forall_coord

end ContDiff

section ContinuityBounds

variable {ùïú E F FHom : Type*} [NormedField ùïú]

@[simp]
lemma AddMonoidHomClass.coe_fn_to_addMonoidHom
    [FunLike FHom E F] [AddZeroClass E] [AddZeroClass F]
    [AddMonoidHomClass FHom E F] (œÜ : FHom) :
    ‚áë(AddMonoidHomClass.toAddMonoidHom œÜ) = ‚áëœÜ := by
  rfl

variable [NormedAddCommGroup E] [NormedSpace ùïú E]
variable [NormedAddCommGroup F] [NormedSpace ùïú F]

/-- A bounded additive map is continuous at zero. -/
lemma AddMonoidHom.continuousAt_zero_of_bound
    (œÜ : AddMonoidHom E F) {C : ‚Ñù} (h : ‚àÄ x, ‚ÄñœÜ x‚Äñ ‚â§ C * ‚Äñx‚Äñ) :
    ContinuousAt œÜ 0 := by
  rw [Metric.continuousAt_iff]
  intro Œµ Œµpos
  simp only [map_zero œÜ, dist_zero_right]
  by_cases hE : Subsingleton E
  ¬∑ use 1
    refine ‚ü®zero_lt_one, fun y _hy_norm_lt_one => ?_‚ü©
    rw [@Subsingleton.elim E hE y 0, map_zero œÜ, norm_zero]
    exact Œµpos
  ¬∑ have C_nonneg : 0 ‚â§ C := by
      obtain ‚ü®x_ne, y_ne, h_x_ne_y‚ü© : ‚àÉ x y : E, x ‚â† y := by
        contrapose! hE; exact { allEq := hE }
      let z := x_ne - y_ne
      have hz_ne_zero : z ‚â† 0 := sub_ne_zero_of_ne h_x_ne_y
      have hz_norm_pos : 0 < ‚Äñz‚Äñ := norm_pos_iff.mpr hz_ne_zero
      by_contra hC_is_neg
      push_neg at hC_is_neg
      have h_phi_z_bound := h z
      have H1 : 0 ‚â§ C * ‚Äñz‚Äñ := le_trans (norm_nonneg (œÜ z)) h_phi_z_bound
      have H2 : C * ‚Äñz‚Äñ < 0 := mul_neg_of_neg_of_pos hC_is_neg hz_norm_pos
      linarith [H1, H2]
    by_cases hC_eq_zero : C = 0
    ¬∑ have phi_is_zero : œÜ = 0 := by
        ext x_val
        have h_phi_x_val_bound := h x_val
        rw [hC_eq_zero, zero_mul] at h_phi_x_val_bound
        exact norm_le_zero_iff.mp h_phi_x_val_bound
      use 1
      refine ‚ü®zero_lt_one, fun y _hy_norm_lt_one => ?_‚ü©
      rw [phi_is_zero, AddMonoidHom.zero_apply, norm_zero]
      exact Œµpos
    ¬∑ have C_pos : 0 < C := lt_of_le_of_ne C_nonneg fun a => hC_eq_zero (_root_.id (Eq.symm a))
      use Œµ / C
      refine ‚ü®div_pos Œµpos C_pos, fun y hy_norm_lt_delta => ?_‚ü©
      calc
        ‚ÄñœÜ y‚Äñ ‚â§ C * ‚Äñy‚Äñ := h y
        _ < C * (Œµ / C) := mul_lt_mul_of_pos_left hy_norm_lt_delta C_pos
        _ = Œµ := by rw [mul_div_cancel‚ÇÄ Œµ hC_eq_zero]

omit [NormedSpace ùïú F] in
/-- A semi-linear map that is linearly bounded by the norm of its input is continuous. -/
lemma SemilinearMapClass.continuous_of_bound {ùïú‚ÇÇ : Type*} [NormedField ùïú‚ÇÇ] [NormedSpace ùïú‚ÇÇ F]
    [FunLike FHom E F] {œÉ : ùïú ‚Üí+* ùïú‚ÇÇ} [SemilinearMapClass FHom œÉ E F]
    {œÜ : FHom} {C : ‚Ñù} (h : ‚àÄ x, ‚ÄñœÜ x‚Äñ ‚â§ C * ‚Äñx‚Äñ) : Continuous œÜ := by
  haveI : AddMonoidHomClass FHom E F := inferInstance
  let œÜ_add_hom : AddMonoidHom E F := AddMonoidHomClass.toAddMonoidHom œÜ
  exact continuous_of_continuousAt_zero œÜ_add_hom
    (AddMonoidHom.continuousAt_zero_of_bound œÜ_add_hom h)

/-- A function that is linearly bounded by the norm of its input is continuous. -/
lemma AddMonoidHomClass.continuous_of_bound' [FunLike FHom E F] [AddMonoidHomClass FHom E F]
    {œÜ : FHom} {C : ‚Ñù} (h : ‚àÄ x, ‚ÄñœÜ x‚Äñ ‚â§ C * ‚Äñx‚Äñ) : Continuous œÜ := by
  let œÜ_add_hom : AddMonoidHom E F := AddMonoidHomClass.toAddMonoidHom œÜ
  exact continuous_of_continuousAt_zero œÜ_add_hom
    (AddMonoidHom.continuousAt_zero_of_bound œÜ_add_hom h)

end ContinuityBounds

namespace ContinuousLinearMap

variable {X‚ÇÅ E‚ÇÅ F‚ÇÅ G‚ÇÅ E‚ÇÅ' F‚ÇÅ' : Type*} [NontriviallyNormedField ùïú‚ÇÅ]
  [NormedAddCommGroup X‚ÇÅ] [NormedSpace ùïú‚ÇÅ X‚ÇÅ]
  [NormedAddCommGroup E‚ÇÅ] [NormedSpace ùïú‚ÇÅ E‚ÇÅ]
  [NormedAddCommGroup F‚ÇÅ] [NormedSpace ùïú‚ÇÅ F‚ÇÅ]
  [NormedAddCommGroup G‚ÇÅ] [NormedSpace ùïú‚ÇÅ G‚ÇÅ]
  [NormedAddCommGroup E‚ÇÅ'] [NormedSpace ùïú‚ÇÅ E‚ÇÅ']
  [NormedAddCommGroup F‚ÇÅ'] [NormedSpace ùïú‚ÇÅ F‚ÇÅ']
  {n‚ÇÅ : WithTop ‚Ñï‚àû}

/-- The `ContinuousLinearMap.bilinearComp` operation is smooth.
    Given smooth functions `f : X‚ÇÅ ‚Üí (E‚ÇÅ ‚ÜíL[ùïú‚ÇÅ] F‚ÇÅ ‚ÜíL[ùïú‚ÇÅ] G‚ÇÅ)`, `g : X‚ÇÅ ‚Üí (E‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] E‚ÇÅ)`,
    and `h : X‚ÇÅ ‚Üí (F‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] F‚ÇÅ)`, the composition `x ‚Ü¶ (f x).bilinearComp (g x) (h x)`
    is smooth. -/
lemma contDiff_bilinearComp
    {f : X‚ÇÅ ‚Üí E‚ÇÅ ‚ÜíL[ùïú‚ÇÅ] F‚ÇÅ ‚ÜíL[ùïú‚ÇÅ] G‚ÇÅ} {g : X‚ÇÅ ‚Üí E‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] E‚ÇÅ} {h : X‚ÇÅ ‚Üí F‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] F‚ÇÅ}
    (hf : ContDiff ùïú‚ÇÅ n‚ÇÅ f) (hg : ContDiff ùïú‚ÇÅ n‚ÇÅ g) (hh : ContDiff ùïú‚ÇÅ n‚ÇÅ h) :
    ContDiff ùïú‚ÇÅ n‚ÇÅ fun x => (f x).bilinearComp (g x) (h x) := by
  have h1 : ContDiff ùïú‚ÇÅ n‚ÇÅ (fun x ‚Ü¶ (f x).comp (g x)) := ContDiff.clm_comp hf hg
  let L_flip1 := ContinuousLinearMap.flip‚Çó·µ¢ ùïú‚ÇÅ E‚ÇÅ' F‚ÇÅ G‚ÇÅ
  have eq_flip : ‚àÄ x, L_flip1 ((f x).comp (g x)) = ((f x).comp (g x)).flip := by
    intro x
    rfl
  have h2 : ContDiff ùïú‚ÇÅ n‚ÇÅ (fun x => ((f x).comp (g x)).flip) := by
    have hL‚ÇÅ : ContDiff ùïú‚ÇÅ n‚ÇÅ L_flip1 :=
      (ContinuousLinearMap.contDiff (ùïú := ùïú‚ÇÅ) (E := E‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] F‚ÇÅ ‚ÜíL[ùïú‚ÇÅ] G‚ÇÅ)
        (F := F‚ÇÅ ‚ÜíL[ùïú‚ÇÅ] E‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] G‚ÇÅ) L_flip1).of_le le_top
    have h2' : ContDiff ùïú‚ÇÅ n‚ÇÅ (fun x => L_flip1 ((f x).comp (g x))) :=
      ContDiff.comp hL‚ÇÅ h1
    exact (funext eq_flip).symm ‚ñ∏ h2'
  have h3 : ContDiff ùïú‚ÇÅ n‚ÇÅ (fun x => (((f x).comp (g x)).flip).comp (h x)) :=
    ContDiff.clm_comp h2 hh
  let L_flip2 := ContinuousLinearMap.flip‚Çó·µ¢ ùïú‚ÇÅ F‚ÇÅ' E‚ÇÅ' G‚ÇÅ
  have eq_flip2 : ‚àÄ x, L_flip2 ((((f x).comp (g x)).flip).comp (h x)) =
      ((((f x).comp (g x)).flip).comp (h x)).flip := by
    intro x
    rfl
  have h4 : ContDiff ùïú‚ÇÅ n‚ÇÅ (fun x => ((((f x).comp (g x)).flip).comp (h x)).flip) := by
    have hL‚ÇÇ : ContDiff ùïú‚ÇÅ n‚ÇÅ L_flip2 :=
      (ContinuousLinearMap.contDiff (ùïú := ùïú‚ÇÅ) (E := F‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] E‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] G‚ÇÅ)
        (F := E‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] F‚ÇÅ' ‚ÜíL[ùïú‚ÇÅ] G‚ÇÅ) L_flip2).of_le le_top
    have h4' := ContDiff.comp hL‚ÇÇ h3
    exact (funext eq_flip2).symm ‚ñ∏ h4'
  exact h4

variable {X‚ÇÅ E‚ÇÅ F‚ÇÅ G‚ÇÅ E‚ÇÅ' F‚ÇÅ' : Type*} [NontriviallyNormedField ùïú‚ÇÅ]
  [NormedAddCommGroup X‚ÇÅ] [NormedSpace ùïú‚ÇÅ X‚ÇÅ]
  [NormedAddCommGroup E‚ÇÅ] [NormedSpace ùïú‚ÇÅ E‚ÇÅ] [FiniteDimensional ùïú‚ÇÅ E‚ÇÅ]
  [NormedAddCommGroup F‚ÇÅ] [NormedSpace ùïú‚ÇÅ F‚ÇÅ] [FiniteDimensional ùïú‚ÇÅ F‚ÇÅ]
  [NormedAddCommGroup G‚ÇÅ] [NormedSpace ùïú‚ÇÅ G‚ÇÅ] [FiniteDimensional ùïú‚ÇÅ G‚ÇÅ]
  [NormedAddCommGroup E‚ÇÅ'] [NormedSpace ùïú‚ÇÅ E‚ÇÅ'] [FiniteDimensional ùïú‚ÇÅ E‚ÇÅ']
  [NormedAddCommGroup F‚ÇÅ'] [NormedSpace ùïú‚ÇÅ F‚ÇÅ'] [FiniteDimensional ùïú‚ÇÅ F‚ÇÅ']
  {n‚ÇÅ : WithTop ‚Ñï‚àû}

/-- The "flip" operation on continuous bilinear maps is smooth. -/
lemma flip_contDiff {F‚ÇÅ F‚ÇÇ R : Type*}
    [NormedAddCommGroup F‚ÇÅ] [NormedSpace ‚Ñù F‚ÇÅ]
    [NormedAddCommGroup F‚ÇÇ] [NormedSpace ‚Ñù F‚ÇÇ]
    [NormedAddCommGroup R] [NormedSpace ‚Ñù R] :
    ContDiff ‚Ñù ‚ä§ (fun f : F‚ÇÅ ‚ÜíL[‚Ñù] F‚ÇÇ ‚ÜíL[‚Ñù] R => ContinuousLinearMap.flip f) := by
  let flip_clm :=
    (ContinuousLinearMap.flip‚Çó·µ¢ ‚Ñù F‚ÇÅ F‚ÇÇ R).toContinuousLinearEquiv.toContinuousLinearMap
  exact
    @ContinuousLinearMap.contDiff ‚Ñù _
      (F‚ÇÅ ‚ÜíL[‚Ñù] F‚ÇÇ ‚ÜíL[‚Ñù] R) _ _ (F‚ÇÇ ‚ÜíL[‚Ñù] F‚ÇÅ ‚ÜíL[‚Ñù] R) _ _ _ flip_clm

/-- Composition of a bilinear map with a linear map in the first argument is smooth. -/
lemma comp_first_contDiff {F‚ÇÅ F‚ÇÇ F‚ÇÉ R : Type*}
    [NormedAddCommGroup F‚ÇÅ] [NormedSpace ‚Ñù F‚ÇÅ]
    [NormedAddCommGroup F‚ÇÇ] [NormedSpace ‚Ñù F‚ÇÇ]
    [NormedAddCommGroup F‚ÇÉ] [NormedSpace ‚Ñù F‚ÇÉ]
    [NormedAddCommGroup R] [NormedSpace ‚Ñù R] :
    ContDiff ‚Ñù ‚ä§ (fun p : (F‚ÇÇ ‚ÜíL[‚Ñù] F‚ÇÉ ‚ÜíL[‚Ñù] R) √ó (F‚ÇÅ ‚ÜíL[‚Ñù] F‚ÇÇ) =>
      ContinuousLinearMap.comp p.1 p.2) := by
  exact ContDiff.clm_comp contDiff_fst contDiff_snd

variable {E‚ÇÅ_‚ÇÇ : Type*} {E‚ÇÇ_‚ÇÇ : Type*} {R‚ÇÇ : Type*}
variable [NormedAddCommGroup E‚ÇÅ_‚ÇÇ] [NormedSpace ‚Ñù E‚ÇÅ_‚ÇÇ]
variable [NormedAddCommGroup E‚ÇÇ_‚ÇÇ] [NormedSpace ‚Ñù E‚ÇÇ_‚ÇÇ]
variable [NormedAddCommGroup R‚ÇÇ] [NormedSpace ‚Ñù R‚ÇÇ]

/-- The pullback of a bilinear map by a linear map is smooth with respect to both arguments. -/
theorem contDiff_pullbackBilinear_op :
    ContDiff ‚Ñù ‚ä§ (fun p : (E‚ÇÇ_‚ÇÇ ‚ÜíL[‚Ñù] E‚ÇÇ_‚ÇÇ ‚ÜíL[‚Ñù] R‚ÇÇ) √ó (E‚ÇÅ_‚ÇÇ ‚ÜíL[‚Ñù] E‚ÇÇ_‚ÇÇ) =>
      BilinearForm.pullback p.1 p.2) := by
  apply contDiff_bilinearComp
  ¬∑ exact (contDiff_fst (E := (E‚ÇÇ_‚ÇÇ ‚ÜíL[‚Ñù] E‚ÇÇ_‚ÇÇ ‚ÜíL[‚Ñù] R‚ÇÇ)) (F := (E‚ÇÅ_‚ÇÇ ‚ÜíL[‚Ñù] E‚ÇÇ_‚ÇÇ))).of_le le_top
  ¬∑ exact (contDiff_snd (E := (E‚ÇÇ_‚ÇÇ ‚ÜíL[‚Ñù] E‚ÇÇ_‚ÇÇ ‚ÜíL[‚Ñù] R‚ÇÇ)) (F := (E‚ÇÅ_‚ÇÇ ‚ÜíL[‚Ñù] E‚ÇÇ_‚ÇÇ))).of_le le_top
  ¬∑ exact (contDiff_snd (E := (E‚ÇÇ_‚ÇÇ ‚ÜíL[‚Ñù] E‚ÇÇ_‚ÇÇ ‚ÜíL[‚Ñù] R‚ÇÇ)) (F := (E‚ÇÅ_‚ÇÇ ‚ÜíL[‚Ñù] E‚ÇÇ_‚ÇÇ))).of_le le_top

end ContinuousLinearMap
