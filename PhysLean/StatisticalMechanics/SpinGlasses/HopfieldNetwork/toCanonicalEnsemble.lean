import PhysLean.StatisticalMechanics.CanonicalEnsemble.TwoState
import PhysLean.StatisticalMechanics.SpinGlasses.HopfieldNetwork.TwoState

open MeasureTheory

/-!
# The Bridge from Neural Networks to Statistical Mechanics

This file defines the `IsHamiltonian` typeclass, which provides the formal bridge
between the constructive, algorithmic definition of a `NeuralNetwork` (Layer 4)
and the physical, probabilistic framework of a `CanonicalEnsemble` (Layer 2).
-/
variable {U œÉ : Type} [Fintype U] [DecidableEq U]

/-- For any finite-state neural network we use the trivial (‚ä§) measurable space. -/
instance (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] : MeasurableSpace NN.State := ‚ä§

omit [Fintype U] [DecidableEq U] in
@[simp] lemma measurable_of_fintype_state
    (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] (f : NN.State ‚Üí ‚Ñù) :
    Measurable f := by
  classical
  unfold Measurable; intro s _; simp

/--
A typeclass asserting that a `NeuralNetwork`'s dynamics are governed by an energy function.
This is the formal statement that the network is a physical system with a well-defined
Hamiltonian, and that its deterministic dynamics are a form of energy minimization.

- `NN`: The concrete `NeuralNetwork` structure.
-/
class IsHamiltonian (NN : NeuralNetwork ‚Ñù U œÉ) [MeasurableSpace NN.State] where
  /-- The energy function (Hamiltonian) of a given state of the network. -/
  energy : Params NN ‚Üí NN.State ‚Üí ‚Ñù
  /-- A proof that the energy function is measurable (trivial for discrete (‚ä§) state spaces). -/
  energy_measurable : ‚àÄ p, Measurable (energy p)
  /-- The core axiom: The energy is a Lyapunov function for the network's asynchronous
  Glauber dynamics. Any single update step does not increase the energy. -/
  energy_is_lyapunov :
    ‚àÄ (p : Params NN) (s : NN.State) (u : U),
      energy p ((NeuralNetwork.State.Up s p u)) ‚â§ energy p s

/--
A formal constructor that lifts any `NeuralNetwork` proven to be `IsHamiltonian`
into the `CanonicalEnsemble` framework.

This function is the bridge that allows us to apply the full power of statistical
mechanics (free energy, entropy, etc.) to a structurally-defined neural network.
-/
@[simps!]
noncomputable def toCanonicalEnsemble
    (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] [IsHamiltonian NN]
    (p : Params NN) :
    CanonicalEnsemble NN.State where
  energy := IsHamiltonian.energy p
  dof := 0 -- For discrete spin systems, there are no continuous degrees of freedom.
  phase_space_unit := 1 -- For counting measures, the unit is 1.
  energy_measurable := IsHamiltonian.energy_measurable p
  Œº := Measure.count -- The natural base measure for a discrete state space.
  Œº_sigmaFinite := by infer_instance

variable {U œÉ : Type} [Fintype U] [DecidableEq U]
variable {NN : NeuralNetwork ‚Ñù U œÉ} [TwoStateNeuralNetwork NN]

/-
This instance is the formal bridge. It is a theorem stating that any `NeuralNetwork`
for which we can provide an `EnergySpec` is guaranteed to be an `IsHamiltonian` system.

Lean's typeclass system will use this instance automatically. If you define an `EnergySpec`
for a network, Lean will now know that it is also `IsHamiltonian`.
-/

/-! ## Generic Hamiltonian bridge (refactored)

We generalize the previous `IsHamiltonian_of_EnergySpecSymmetricBinary` to any
two‚Äìstate neural network for which the activation predicate `pact` is *exactly*
the two distinguished states `œÉ_pos` and `œÉ_neg`.  This is captured by the
`TwoStateExclusive` predicate below.  For such networks, an `EnergySpec'`
immediately yields an `IsHamiltonian` instance, reusing the generic
`energy_is_lyapunov_at_site''` lemma (no binary‚Äìspecialized reproofs). -/

namespace TwoState

/-- Exclusivity predicate: the allowed activations are precisely `œÉ_pos` or `œÉ_neg`. -/
class TwoStateExclusive
    {U œÉ} (NN : NeuralNetwork ‚Ñù U œÉ)
    [TwoStateNeuralNetwork NN] : Prop where
  (pact_iff : ‚àÄ a, NN.pact a ‚Üî
      a = TwoStateNeuralNetwork.œÉ_pos (NN:=NN) ‚à®
      a = TwoStateNeuralNetwork.œÉ_neg (NN:=NN))

attribute [simp] TwoStateExclusive.pact_iff

/-- Instance: `SymmetricBinary` activations are exactly `{1,-1}`. -/
instance (U) [Fintype U] [DecidableEq U] [Nonempty U] :
  TwoStateExclusive (TwoState.SymmetricBinary ‚Ñù U) where
  pact_iff a := by
    -- pact definition: a = 1 ‚à® a = -1
    simp [TwoState.SymmetricBinary]
    aesop

/-- Instance: `ZeroOne` activations are exactly `{0,1}`. -/
instance zeroOneExclusive (U) [Fintype U] [DecidableEq U] [Nonempty U] :
  TwoStateExclusive (TwoState.ZeroOne ‚Ñù U) where
  pact_iff a := by
    -- pact definition: a = 0 ‚à® a = 1
    simp [TwoState.ZeroOne, TwoState.SymmetricBinary]
    aesop

/-- Instance: `SymmetricSignum` activations (two-point type) are exactly the two constructors. -/
instance signumExclusive (U) [Fintype U] [DecidableEq U] [Nonempty U] :
  TwoStateExclusive (TwoState.SymmetricSignum ‚Ñù U) where
  pact_iff a := by
    -- pact is `True`; every `a` is either `pos` or `neg` by exhaustive cases.
    cases a <;> simp [TwoState.SymmetricSignum]
    all_goals aesop

end TwoState

open TwoState

variable {U œÉ : Type} [Fintype U] [DecidableEq U]
variable {NN : NeuralNetwork ‚Ñù U œÉ} [TwoStateNeuralNetwork NN]

/-- Generic bridge: any exclusive two‚Äìstate NN with an `EnergySpec'` is Hamiltonian.
Added `[Fintype NN.State]` so the `(‚ä§)` measurable space instance is available,
fixing the missing `MeasurableSpace NN.State` error. -/
noncomputable instance IsHamiltonian_of_EnergySpec'
    (spec : TwoState.EnergySpec' (NN:=NN))
    [Fintype NN.State]                -- NEW: ensures MeasurableSpace instance via the earlier `[Fintype]` ‚Üí `‚ä§`
    [TwoStateExclusive (NN:=NN)] :
    IsHamiltonian (U:=U) (œÉ:=œÉ) NN where
  energy := spec.E
  energy_measurable := by
    intro p
    -- finite state space ‚áí every function measurable
    have : Measurable (spec.E p) :=
      measurable_of_fintype_state (NN:=NN) (f:=spec.E p)
    simp
  energy_is_lyapunov := by
    intro p s u
    classical
    have hcur :=
      (TwoStateExclusive.pact_iff (NN:=NN) (a:=s.act u)).1 (s.hp u)
    exact TwoState.EnergySpec'.energy_is_lyapunov_at_site''
            (NN:=NN) spec p s u hcur

/--
Backward compatibility: the old SymmetricBinary-specific instance is now
substantiated by the generic one.  (Kept for clarity; can be removed safely.)
-/
@[deprecated IsHamiltonian_of_EnergySpec' (since := "2025-08-24")]
noncomputable def IsHamiltonian_of_EnergySpecSymmetricBinary
    {U : Type} [Fintype U] [DecidableEq U] [Nonempty U]
    [Fintype (TwoState.SymmetricBinary ‚Ñù U).State]
    (spec : TwoState.EnergySpec' (NN:=TwoState.SymmetricBinary ‚Ñù U)) :
    IsHamiltonian (TwoState.SymmetricBinary ‚Ñù U) :=
  (IsHamiltonian_of_EnergySpec' (NN:=TwoState.SymmetricBinary ‚Ñù U) (spec:=spec))

open CanonicalEnsemble
open scoped BigOperators

variable {U : Type} [Fintype U] [DecidableEq U]

/-- Abbreviation: the canonical ensemble associated to a Hamiltonian neural network. -/
noncomputable abbrev hopfieldCE
    (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] [IsHamiltonian (U:=U) (œÉ:=œÉ) NN]
    (p : Params NN) :
    CanonicalEnsemble NN.State :=
  toCanonicalEnsemble (U:=U) (œÉ:=œÉ) NN p

/-- The induced finite‚Äìensemble structure (counting measure, dof = 0, unit = 1). -/
instance
    (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] [IsHamiltonian (U:=U) (œÉ:=œÉ) NN]
    (p : Params NN) :
    CanonicalEnsemble.IsFinite (hopfieldCE (U:=U) (œÉ:=œÉ) NN p) where
  Œº_eq_count := rfl
  dof_eq_zero := rfl
  phase_space_unit_eq_one := rfl

omit [Fintype U] in
@[simp]
lemma hopfieldCE_dof
    (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] [IsHamiltonian (U:=U) (œÉ:=œÉ) NN]
    (p : Params NN) :
    (hopfieldCE (U:=U) (œÉ:=œÉ) NN p).dof = 0 := rfl

omit [Fintype U] in
@[simp]
lemma hopfieldCE_phase_space_unit
    (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] [IsHamiltonian (U:=U) (œÉ:=œÉ) NN]
    (p : Params NN) :
    (hopfieldCE (U:=U) (œÉ:=œÉ) NN p).phase_space_unit = 1 := rfl

omit [Fintype U] in
/-- Uniform probability for a constant-energy Hamiltonian (sanity test of the bridge). -/
lemma hopfieldCE_probability_const_energy
    (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] [IsHamiltonian (U:=U) (œÉ:=œÉ) NN]
    (p : Params NN) (c : ‚Ñù)
    (hE : ‚àÄ s, IsHamiltonian.energy (U:=U) (œÉ:=œÉ) (NN:=NN) p s = c)
    (T : Temperature) (s : NN.State) :
    (hopfieldCE (U:=U) (œÉ:=œÉ) NN p).probability T s
      = (1 : ‚Ñù) / (Fintype.card NN.State) := by
  classical
  set ùìí := hopfieldCE (U:=U) (œÉ:=œÉ) NN p
  have hZ :=
    (mathematicalPartitionFunction_of_fintype (ùìí:=ùìí) T)
  have hZconst :
      ùìí.mathematicalPartitionFunction T
        = (Fintype.card NN.State : ‚Ñù) * Real.exp (-(T.Œ≤ : ‚Ñù) * c) := by
    have hsum :
        (‚àë s : NN.State, Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy s))
          = (‚àë _ : NN.State, Real.exp (-(T.Œ≤ : ‚Ñù) * c)) := by
      refine Finset.sum_congr rfl ?_
      intro s _; simp [ùìí, toCanonicalEnsemble, hE]
    have hsumConst :
        (‚àë _ : NN.State, Real.exp (-(T.Œ≤ : ‚Ñù) * c))
          = (Fintype.card NN.State : ‚Ñï) ‚Ä¢ Real.exp (-(T.Œ≤ : ‚Ñù) * c) := by
      simp [Finset.sum_const, Finset.card_univ]
    have hnsmul :
        ((Fintype.card NN.State : ‚Ñï) ‚Ä¢ Real.exp (-(T.Œ≤ : ‚Ñù) * c))
          = (Fintype.card NN.State : ‚Ñù) * Real.exp (-(T.Œ≤ : ‚Ñù) * c) := by
      simp
    simp [hZ, hsum, hsumConst, hnsmul]
    aesop
  unfold CanonicalEnsemble.probability
  have hexp_ne : Real.exp (-(T.Œ≤ : ‚Ñù) * c) ‚â† 0 := (Real.exp_pos _).ne'
  simp_rw [ùìí, toCanonicalEnsemble, hE]
  erw [hZconst]
  simp [one_div, div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc, hexp_ne]

omit [Fintype U] in
/-- Corollary: mean energy = constant `c` under the induced canonical ensemble,
    for a constant-energy network. -/
lemma hopfieldCE_meanEnergy_const
    (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] [Nonempty NN.State]
    [IsHamiltonian (U:=U) (œÉ:=œÉ) NN]
    (p : Params NN) (c : ‚Ñù)
    (hE : ‚àÄ s, IsHamiltonian.energy (U:=U) (œÉ:=œÉ) (NN:=NN) p s = c)
    (T : Temperature) :
    (hopfieldCE (U:=U) (œÉ:=œÉ) NN p).meanEnergy T = c := by
  classical
  set ùìí := hopfieldCE (U:=U) (œÉ:=œÉ) NN p
  have hZeq :
      ùìí.mathematicalPartitionFunction T
        = (Fintype.card NN.State : ‚Ñù) * Real.exp (-(T.Œ≤ : ‚Ñù) * c) := by
    have hZform := (mathematicalPartitionFunction_of_fintype (ùìí:=ùìí) T)
    have :
        (‚àë s : NN.State, Real.exp (-(T.Œ≤ : ‚Ñù) * ùìí.energy s))
          = (Fintype.card NN.State : ‚Ñù) * Real.exp (-(T.Œ≤ : ‚Ñù) * c) := by
      have hconst :
          (‚àë _ : NN.State, Real.exp (-(T.Œ≤ : ‚Ñù) * c))
            = (Fintype.card NN.State : ‚Ñï) ‚Ä¢ Real.exp (-(T.Œ≤ : ‚Ñù) * c) := by
        simp [Finset.sum_const, Finset.card_univ]
      simp [ùìí, toCanonicalEnsemble, hE, hconst, nsmul_eq_mul,
            mul_comm, mul_left_comm, mul_assoc]
    simpa [hZform]
  have hNum' :
      (‚àë s : NN.State,
          IsHamiltonian.energy (U:=U) (œÉ:=œÉ) (NN:=NN) p s *
            Real.exp (-(T.Œ≤ : ‚Ñù) *
              IsHamiltonian.energy (U:=U) (œÉ:=œÉ) (NN:=NN) p s))
        = c * ùìí.mathematicalPartitionFunction T := by
    have hNumEq :
        (‚àë s : NN.State,
            IsHamiltonian.energy (U:=U) (œÉ:=œÉ) (NN:=NN) p s *
              Real.exp (-(T.Œ≤ : ‚Ñù) *
                IsHamiltonian.energy (U:=U) (œÉ:=œÉ) (NN:=NN) p s))
          = c * ((Fintype.card NN.State : ‚Ñù) *
                Real.exp (-(T.Œ≤ : ‚Ñù) * c)) := by
      have hconst :
          (‚àë _ : NN.State,
              c * Real.exp (-(T.Œ≤ : ‚Ñù) * c))
            = (Fintype.card NN.State : ‚Ñï) ‚Ä¢ (c * Real.exp (-(T.Œ≤ : ‚Ñù) * c)) := by
        simp [Finset.sum_const, Finset.card_univ]
      simp [ùìí, toCanonicalEnsemble, hE, hconst, nsmul_eq_mul,
            mul_comm, mul_left_comm, mul_assoc]
    simpa [hZeq, mul_comm, mul_left_comm, mul_assoc] using hNumEq
  unfold CanonicalEnsemble.meanEnergy
  have hZne : ùìí.mathematicalPartitionFunction T ‚â† 0 := by
    have hcard : 0 < (Fintype.card NN.State : ‚Ñù) := by
      have : 0 < Fintype.card NN.State := Fintype.card_pos_iff.mpr inferInstance
      exact_mod_cast this
    have hpos :
        0 < (Fintype.card NN.State : ‚Ñù) * Real.exp (-(T.Œ≤ : ‚Ñù) * c) :=
      mul_pos hcard (Real.exp_pos _)
    simp [hZeq]
  aesop

-- Inheritance showcase: canonical‚Äìensemble facts usable for Hopfield networks.
section CanonicalEnsembleInheritanceExamples
variable {U œÉ : Type} [Fintype U] [DecidableEq U]
variable (NN : NeuralNetwork ‚Ñù U œÉ) [Fintype NN.State] [Nonempty NN.State]
variable [IsHamiltonian (U:=U) (œÉ:=œÉ) NN]
variable (p : Params NN) (T : Temperature)
variable (s : NN.State)

-- Basic objects
#check (hopfieldCE (U:=U) (œÉ:=œÉ) NN p).partitionFunction
#check (hopfieldCE (U:=U) (œÉ:=œÉ) NN p).mathematicalPartitionFunction

-- Positivity (finite specialization)
#check (mathematicalPartitionFunction_pos_finite
          (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN p) (T:=T))
#check (partitionFunction_pos_finite
          (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN p) (T:=T))

-- Probability normalization & basic bounds
#check (sum_probability_eq_one
          (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN p) (T:=T))
#check (probability_nonneg_finite
          (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN p) (T:=T) (i:=s))

-- Entropy identifications in finite case
#check (shannonEntropy_eq_differentialEntropy
          (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN p) (T:=T))
#check (thermodynamicEntropy_eq_shannonEntropy
          (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN p) (T:=T))

-- Additivity for two independent Hopfield ensembles (same phase_space_unit = 1)
variable (NN‚ÇÅ NN‚ÇÇ : NeuralNetwork ‚Ñù U œÉ)
variable [Fintype NN‚ÇÅ.State] [Nonempty NN‚ÇÅ.State] [IsHamiltonian (U:=U) (œÉ:=œÉ) NN‚ÇÅ]
variable [Fintype NN‚ÇÇ.State] [Nonempty NN‚ÇÇ.State] [IsHamiltonian (U:=U) (œÉ:=œÉ) NN‚ÇÇ]
variable (p‚ÇÅ : Params NN‚ÇÅ) (p‚ÇÇ : Params NN‚ÇÇ)

#check partitionFunction_add
  (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN‚ÇÅ p‚ÇÅ)
  (ùìí1:=hopfieldCE (U:=U) (œÉ:=œÉ) NN‚ÇÇ p‚ÇÇ)
  (T:=T) (by simp)
#check helmholtzFreeEnergy_add
  (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN‚ÇÅ p‚ÇÅ)
  (ùìí1:=hopfieldCE (U:=U) (œÉ:=œÉ) NN‚ÇÇ p‚ÇÇ)
  (T:=T) (by simp)
#check meanEnergy_add
  (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN‚ÇÅ p‚ÇÅ)
  (ùìí1:=hopfieldCE (U:=U) (œÉ:=œÉ) NN‚ÇÇ p‚ÇÇ)

-- n independent copies (scaling laws)
#check partitionFunction_nsmul
  (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN p) (n:=3) (T:=T)
#check helmholtzFreeEnergy_nsmul
  (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN p) (n:=3) (T:=T)
#check meanEnergy_nsmul
  (ùìí:=hopfieldCE (U:=U) (œÉ:=œÉ) NN p) (n:=3) (T:=T)

end CanonicalEnsembleInheritanceExamples
