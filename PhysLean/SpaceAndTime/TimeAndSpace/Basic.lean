/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhi Kai Pong, Joseph Tooby-Smith
-/
import PhysLean.SpaceAndTime.Time.Derivatives
import PhysLean.Mathematics.Distribution.Function.OfFunction
import Mathlib.MeasureTheory.SpecificCodomains.WithLp
import PhysLean.SpaceAndTime.Space.Derivatives.Curl
/-!

# Functions and distributions on Time and Space d

## i. Overview

In this module we define and prove basic lemmas about derivatives of functions and
distributions on both `Time` and `Space d`.

We put these results in the namespace `Space` by convention.

## ii. Key results

- `distTimeDeriv` : The derivative of a distribution on `Time √ó Space d` along the
  temporal coordinate.
- `distSpaceDeriv` : The derivative of a distribution on `Time √ó Space d` along the
  spatial `i` coordinate.
- `distSpaceGrad` : The spatial gradient of a distribution on `Time √ó Space d`.
- `distSpaceDiv` : The spatial divergence of a distribution on `Time √ó Space d`.
- `distSpaceCurl` : The spatial curl of a distribution on `Time √ó Space 3`.

## iii. Table of contents

- A. Derivatives involving time and space
  - A.1. Space and time derivatives in terms of curried functions
  - A.2. Commuting time and space derivatives
  - A.3. Differentiablity conditions
  - A.4. Time derivative commute with curl
- B. Derivatives of distributions on Time √ó Space d
  - B.1. Time derivatives
  - B.2. Space derivatives
    - B.2.1. Space derivatives commute
  - B.3. Time and space derivatives commute
  - B.4. The spatial gradient
  - B.5. The spatial divergence
  - B.6. The spatial curl

## iv. References

-/
namespace Space

/-!

## A. Derivatives involving time and space

-/

/-!

### A.1. Space and time derivatives in terms of curried functions

-/

lemma fderiv_space_eq_fderiv_curry {M} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (f : Time ‚Üí Space d ‚Üí M) (t : Time) (x dx : Space d)
    (hf : Differentiable ‚Ñù ‚Üøf) :
    fderiv ‚Ñù (fun x' => f t x') x dx = fderiv ‚Ñù ‚Üøf (t, x) (0, dx) := by
  change fderiv ‚Ñù (‚Üøf ‚àò fun x' => (t, x')) x dx = _
  rw [fderiv_comp]
  simp
  rw [DifferentiableAt.fderiv_prodMk]
  simp
  repeat' fun_prop

lemma fderiv_time_eq_fderiv_curry {M} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (f : Time ‚Üí Space d ‚Üí M) (t dt : Time) (x : Space d)
    (hf : Differentiable ‚Ñù ‚Üøf) :
    fderiv ‚Ñù (fun t' => f t' x) t dt = fderiv ‚Ñù ‚Üøf (t, x) (dt, 0) := by
  change fderiv ‚Ñù (‚Üøf ‚àò fun t' => (t', x)) t dt = _
  rw [fderiv_comp]
  simp
  rw [DifferentiableAt.fderiv_prodMk]
  simp
  repeat' fun_prop

/-!

### A.2. Commuting time and space derivatives

-/

/-- Derivatives along space coordinates and time commute. -/
lemma fderiv_time_commute_fderiv_space {M} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (f : Time ‚Üí Space d ‚Üí M) (t dt : Time) (x dx : Space d)
    (hf : ContDiff ‚Ñù 2 ‚Üøf) :
    fderiv ‚Ñù (fun t' => fderiv ‚Ñù (fun x' => f t' x') x dx) t dt
    = fderiv ‚Ñù (fun x' => fderiv ‚Ñù (fun t' => f t' x') t dt) x dx := by
  trans fderiv ‚Ñù (fun t' => (fderiv ‚Ñù (‚Üøf) (t', x) (0, dx))) t dt
  ¬∑ congr
    funext t'
    apply fderiv_space_eq_fderiv_curry
    exact hf.differentiable (by simp)
  trans fderiv ‚Ñù (fun x => (fderiv ‚Ñù (‚Üøf) x (0, dx))) (t, x) (dt, 0)
  ¬∑ let f' : Time ‚Üí Space d ‚Üí M := fun t x => fderiv ‚Ñù (‚Üøf) (t, x) (0, dx)
    change (fderiv ‚Ñù (fun t' => f' t' x) t) dt = _
    rw [fderiv_time_eq_fderiv_curry]
    rfl
    fun_prop
  symm
  trans fderiv ‚Ñù (fun x' => (fderiv ‚Ñù (‚Üøf) (t, x') (dt, 0))) x dx
  ¬∑ congr
    funext x'
    apply fderiv_time_eq_fderiv_curry
    exact hf.differentiable (by simp)
  trans fderiv ‚Ñù (fun t => (fderiv ‚Ñù (‚Üøf) t (dt, 0))) (t, x) (0, dx)
  ¬∑ let f'' : Time ‚Üí Space d ‚Üí M := fun t x => fderiv ‚Ñù (‚Üøf) (t, x) (dt, 0)
    change (fderiv ‚Ñù (fun x' => f'' t x') x) dx = _
    rw [fderiv_space_eq_fderiv_curry]
    rfl
    fun_prop
  rw [fderiv_clm_apply, fderiv_clm_apply]
  simp only [fderiv_fun_const, Pi.ofNat_apply, ContinuousLinearMap.comp_zero, zero_add,
    ContinuousLinearMap.flip_apply]
  rw [IsSymmSndFDerivAt.eq]
  ¬∑ apply ContDiffAt.isSymmSndFDerivAt
    apply ContDiff.contDiffAt
    exact hf
    simp
  repeat' fun_prop

lemma time_deriv_comm_space_deriv {d i} {M} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    {f : Time ‚Üí Space d ‚Üí M} (hf : ContDiff ‚Ñù 2 ‚Üøf) (t : Time) (x : Space d) :
    Time.deriv (fun t' => Space.deriv i (f t') x) t
    = Space.deriv i (fun x' => Time.deriv (fun t' => f t' x') t) x := by
  simp only [Time.deriv_eq, Space.deriv_eq_fderiv_basis]
  exact fderiv_time_commute_fderiv_space f t 1 x (Space.basis i) hf

/-!

### A.3. Differentiablity conditions

-/

@[fun_prop]
lemma space_deriv_differentiable_time {d i} {M} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    {f : Time ‚Üí Space d ‚Üí M} (hf : ContDiff ‚Ñù 2 ‚Üøf) (x : Space d) :
    Differentiable ‚Ñù (fun t => Space.deriv i (f t) x) := by
  conv =>
    enter [2, t];
    rw [Space.deriv_eq_fderiv_basis]
  apply Differentiable.clm_apply
  ¬∑ have hdd : Differentiable ‚Ñù ‚Üøf := hf.differentiable (by simp)
    have h1 (t : Time) : fderiv ‚Ñù (fun x => f t x) x
      = fderiv ‚Ñù (‚Üøf) (t, x) ‚àòL (ContinuousLinearMap.inr ‚Ñù Time (Space d)) := by
      ext w
      simp only [ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.inr_apply]
      rw [‚Üê fderiv_space_eq_fderiv_curry f t x w hdd]
    conv =>
      enter [2, y]
      change fderiv ‚Ñù (fun x => f y x) x
      rw [h1]
    fun_prop
  ¬∑ fun_prop

@[fun_prop]
lemma time_deriv_differentiable_space {d } {M} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    {f : Time ‚Üí Space d ‚Üí M} (hf : ContDiff ‚Ñù 2 ‚Üøf) (t : Time) :
    Differentiable ‚Ñù (fun x => Time.deriv (f ¬∑ x) t) := by
  conv =>
    enter [2, x];
    rw [Time.deriv_eq]
  apply Differentiable.clm_apply
  ¬∑ have hdd : Differentiable ‚Ñù ‚Üøf := hf.differentiable (by simp)
    have h1 (x : Space d) : fderiv ‚Ñù (fun t => f t x) t
      = fderiv ‚Ñù (‚Üøf) (t, x) ‚àòL (ContinuousLinearMap.inl ‚Ñù Time (Space d)) := by
      ext w
      simp only [ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.inl_apply]
      rw [‚Üê fderiv_time_eq_fderiv_curry f t w x hdd]
    conv =>
      enter [2, t']
      change fderiv ‚Ñù (fun x => f x t') t
      rw [h1]
    fun_prop
  ¬∑ fun_prop

@[fun_prop]
lemma curl_differentiable_time
    (f‚Çú : Time ‚Üí Space ‚Üí EuclideanSpace ‚Ñù (Fin 3))
    (hf : ContDiff ‚Ñù 2 ‚Üøf‚Çú) (x : Space) :
    Differentiable ‚Ñù (fun t => (‚àá √ó f‚Çú t) x) := by
  rw [differentiable_euclidean]
  intro i
  fin_cases i
  all_goals
    simp [curl, Space.coord_apply]
    fun_prop

/-!

### A.4. Time derivative commute with curl

-/
open Time

/-- Curl and time derivative commute. -/
lemma time_deriv_curl_commute (f‚Çú : Time ‚Üí Space ‚Üí EuclideanSpace ‚Ñù (Fin 3))
    (t : Time) (x : Space) (hf : ContDiff ‚Ñù 2 ‚Üøf‚Çú) :
    ‚àÇ‚Çú (fun t => (‚àá √ó f‚Çú t) x) t = (‚àá √ó fun x => (‚àÇ‚Çú (fun t => f‚Çú t x) t)) x:= by
  funext i
  rw [‚Üê Time.deriv_euclid]
  ¬∑ fin_cases i
    all_goals
    simp [curl, Space.coord_apply]
    rw [Time.deriv_eq]
    rw [fderiv_fun_sub]
    simp [‚Üê Time.deriv_eq]
    rw [time_deriv_comm_space_deriv, time_deriv_comm_space_deriv]
    congr
    ¬∑ funext x'
      rw [Time.deriv_euclid]
      have h1 := hf.differentiable (by simp)
      fun_prop
    ¬∑ funext x'
      rw [Time.deriv_euclid]
      have h1 := hf.differentiable (by simp)
      fun_prop
    repeat' fun_prop
    ¬∑ apply Differentiable.differentiableAt
      fun_prop
    ¬∑ apply Differentiable.differentiableAt
      fun_prop
  ¬∑ fun_prop

/-!

## B. Derivatives of distributions on Time √ó Space d

-/

open Distribution SchwartzMap

/-!

### B.1. Time derivatives

-/

/-- The time derivative of a distribution dependent on time and space. -/
noncomputable def distTimeDeriv {M d} [NormedAddCommGroup M] [NormedSpace ‚Ñù M] :
    ((Time √ó Space d) ‚Üíd[‚Ñù] M) ‚Üí‚Çó[‚Ñù] (Time √ó Space d) ‚Üíd[‚Ñù] M where
  toFun f :=
    let ev : ((Time √ó Space d) ‚ÜíL[‚Ñù] M) ‚ÜíL[‚Ñù] M := {
      toFun v := v (1, 0)
      map_add' v1 v2 := by
        simp only [ContinuousLinearMap.add_apply]
      map_smul' a v := by
        simp
    }
    ev.comp (Distribution.fderivD ‚Ñù f)
  map_add' f1 f2 := by
    simp
  map_smul' a f := by simp

lemma distTimeDeriv_apply {M d} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (f : (Time √ó Space d) ‚Üíd[‚Ñù] M) (Œµ : ùì¢(Time √ó Space d, ‚Ñù)) :
    (distTimeDeriv f) Œµ = fderivD ‚Ñù f Œµ (1, 0) := by
  simp [distTimeDeriv]

/-!

### B.2. Space derivatives

-/

/-- The space derivative of a distribution dependent on time and space. -/
noncomputable def distSpaceDeriv {M d} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (i : Fin d) : ((Time √ó Space d) ‚Üíd[‚Ñù] M) ‚Üí‚Çó[‚Ñù] (Time √ó Space d) ‚Üíd[‚Ñù] M where
  toFun f :=
    let ev : (Time √ó Space d ‚ÜíL[‚Ñù] M) ‚ÜíL[‚Ñù] M := {
      toFun v := v (0, basis i)
      map_add' v1 v2 := by
        simp only [ContinuousLinearMap.add_apply]
      map_smul' a v := by
        simp
    }
    ev.comp (Distribution.fderivD ‚Ñù f)
  map_add' f1 f2 := by
    simp
  map_smul' a f := by simp

lemma distSpaceDeriv_apply {M d} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (i : Fin d) (f : (Time √ó Space d) ‚Üíd[‚Ñù] M) (Œµ : ùì¢(Time √ó Space d, ‚Ñù)) :
    (distSpaceDeriv i f) Œµ = fderivD ‚Ñù f Œµ (0, basis i) := by
  simp [distSpaceDeriv]

/-!

#### B.2.1. Space derivatives commute

-/

lemma distSpaceDeriv_commute {M d} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (i j : Fin d) (f : (Time √ó Space d) ‚Üíd[‚Ñù] M) :
    distSpaceDeriv i (distSpaceDeriv j f) = distSpaceDeriv j (distSpaceDeriv i f) := by
  ext Œ∫
  rw [distSpaceDeriv_apply, distSpaceDeriv_apply, fderivD_apply, fderivD_apply]
  rw [distSpaceDeriv_apply, distSpaceDeriv_apply, fderivD_apply, fderivD_apply]
  simp
  congr 1
  ext x
  change fderiv ‚Ñù (fun x => fderiv ‚Ñù Œ∫ x (0, basis i)) x (0, basis j) =
    fderiv ‚Ñù (fun x => fderiv ‚Ñù Œ∫ x (0, basis j)) x (0, basis i)
  rw [fderiv_clm_apply, fderiv_clm_apply]
  simp only [fderiv_fun_const, Pi.ofNat_apply, ContinuousLinearMap.comp_zero, zero_add,
    ContinuousLinearMap.flip_apply]
  rw [IsSymmSndFDerivAt.eq]
  ¬∑ apply ContDiffAt.isSymmSndFDerivAt
    apply ContDiff.contDiffAt
    exact smooth Œ∫ ‚ä§
    simp
    exact ENat.LEInfty.out
  ¬∑ have h1 := smooth Œ∫ 2
    fun_prop
  ¬∑ fun_prop
  ¬∑ have h1 := smooth Œ∫ 2
    fun_prop
  ¬∑ fun_prop

/-!

### B.3. Time and space derivatives commute

-/

lemma distTimeDeriv_commute_distSpaceDeriv {M d} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (i : Fin d) (f : (Time √ó Space d) ‚Üíd[‚Ñù] M) :
    distTimeDeriv (distSpaceDeriv i f) = distSpaceDeriv i (distTimeDeriv f) := by
  ext Œ∫
  rw [distTimeDeriv_apply, distSpaceDeriv_apply, fderivD_apply, fderivD_apply]
  rw [distTimeDeriv_apply, distSpaceDeriv_apply, fderivD_apply, fderivD_apply]
  simp
  congr 1
  ext x
  change fderiv ‚Ñù (fun x => fderiv ‚Ñù Œ∫ x (1, 0)) x (0, basis i) =
    fderiv ‚Ñù (fun x => fderiv ‚Ñù Œ∫ x (0, basis i)) x (1, 0)
  rw [fderiv_clm_apply, fderiv_clm_apply]
  simp only [fderiv_fun_const, Pi.ofNat_apply, ContinuousLinearMap.comp_zero, zero_add,
    ContinuousLinearMap.flip_apply]
  rw [IsSymmSndFDerivAt.eq]
  ¬∑ apply ContDiffAt.isSymmSndFDerivAt
    apply ContDiff.contDiffAt
    exact smooth Œ∫ ‚ä§
    simp
    exact ENat.LEInfty.out
  ¬∑ have h1 := smooth Œ∫ 2
    fun_prop
  ¬∑ fun_prop
  ¬∑ have h1 := smooth Œ∫ 2
    fun_prop
  ¬∑ fun_prop

/-!

### B.4. The spatial gradient

-/

/-- The spatial gradient of a distribution dependent on time and space. -/
noncomputable def distSpaceGrad {d} :
    ((Time √ó Space d) ‚Üíd[‚Ñù] ‚Ñù) ‚Üí‚Çó[‚Ñù] (Time √ó Space d) ‚Üíd[‚Ñù] (EuclideanSpace ‚Ñù (Fin d)) where
  toFun f := {
      toFun := fun Œµ i => distSpaceDeriv i f Œµ
      map_add' Œµ1 Œµ2 := by funext i; simp
      map_smul' a Œµ := by funext i; simp
      cont := by fun_prop}
  map_add' f1 f2 := by
    ext x
    simp
  map_smul' a f := by
    ext x
    simp

lemma distSpaceGrad_apply {d} (f : (Time √ó Space d) ‚Üíd[‚Ñù] ‚Ñù) (Œµ : ùì¢(Time √ó Space d, ‚Ñù)) :
    distSpaceGrad f Œµ = fun i => distSpaceDeriv i f Œµ := by
  rfl

/-!

### B.5. The spatial divergence

-/

/-- The spatial divergence of a distribution dependent on time and space. -/
noncomputable def distSpaceDiv {d} :
    ((Time √ó Space d) ‚Üíd[‚Ñù] (EuclideanSpace ‚Ñù (Fin d))) ‚Üí‚Çó[‚Ñù] (Time √ó Space d) ‚Üíd[‚Ñù] ‚Ñù where
  toFun f := {
    toFun Œµ := ‚àë i, distSpaceDeriv i f Œµ i
    map_add' Œµ1 Œµ2 := by simp [Finset.sum_add_distrib]
    map_smul' a Œµ := by simp [Finset.mul_sum]
    cont := by fun_prop}
  map_add' f1 f2 := by
    ext x
    simp [Finset.sum_add_distrib]
  map_smul' a f := by
    ext x
    simp [Finset.mul_sum]

lemma distSpaceDiv_apply_eq_sum_distSpaceDeriv {d}
    (f : (Time √ó Space d) ‚Üíd[‚Ñù] EuclideanSpace ‚Ñù (Fin d)) (Œ∑ : ùì¢(Time √óSpace d, ‚Ñù)) :
    distSpaceDiv f Œ∑ = ‚àë i, distSpaceDeriv i f Œ∑ i := by rfl

/-!

### B.6. The spatial curl

-/

/-- The curl of a distribution dependent on time and space. -/
noncomputable def distSpaceCurl : ((Time √ó Space 3) ‚Üíd[‚Ñù] (EuclideanSpace ‚Ñù (Fin 3))) ‚Üí‚Çó[‚Ñù]
    (Time √ó Space 3) ‚Üíd[‚Ñù] (EuclideanSpace ‚Ñù (Fin 3)) where
  toFun f :={
    toFun Œµ := fun i =>
      match i with
      | 0 => distSpaceDeriv 2 f Œµ 1 - distSpaceDeriv 1 f Œµ 2
      | 1 => distSpaceDeriv 0 f Œµ 2 - distSpaceDeriv 2 f Œµ 0
      | 2 => distSpaceDeriv 1 f Œµ 0 - distSpaceDeriv 0 f Œµ 1
    map_add' Œµ1 Œµ2 := by
      funext i
      fin_cases i
      all_goals
        simp only [Fin.isValue, map_add, PiLp.add_apply, Fin.reduceFinMk]
        ring
    map_smul' a Œµ := by
      funext i
      fin_cases i
      all_goals
        simp only [Fin.isValue, map_smul, PiLp.smul_apply, smul_eq_mul, RingHom.id_apply,
          Fin.zero_eta]
        ring
    cont := by
      rw [continuous_pi_iff]
      intro i
      fin_cases i <;> fun_prop
      }
  map_add' f1 f2 := by
    ext x i
    fin_cases i
    all_goals
      simp only [Fin.isValue, map_add, ContinuousLinearMap.add_apply, PiLp.add_apply, Fin.zero_eta,
        ContinuousLinearMap.coe_mk', LinearMap.coe_mk, AddHom.coe_mk]
      ring
  map_smul' a f := by
    ext x i
    fin_cases i
    all_goals
      simp only [Fin.isValue, map_smul, ContinuousLinearMap.coe_smul', Pi.smul_apply,
        PiLp.smul_apply, smul_eq_mul, Fin.reduceFinMk, ContinuousLinearMap.coe_mk',
        LinearMap.coe_mk, AddHom.coe_mk, RingHom.id_apply]
      ring

end Space
