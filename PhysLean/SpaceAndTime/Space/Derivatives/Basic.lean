/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhi Kai Pong, Joseph Tooby-Smith, Lode Vermeulen
-/
import PhysLean.SpaceAndTime.SpaceTime.Basic
import Mathlib.Analysis.InnerProductSpace.Calculus
import Mathlib.Analysis.Calculus.FDeriv.Symmetric
import Mathlib.Analysis.SpecialFunctions.Pow.Deriv
import Mathlib.Analysis.Calculus.Gradient.Basic
import PhysLean.Mathematics.Distribution.Function.OfFunction
import Mathlib.MeasureTheory.SpecificCodomains.WithLp
/-!

# Derivatives on Space

In this module, we define the the type `Space d` which corresponds
to a `d`-dimensional Euclidean space and prove some properties about it.

PhysLean sits downstream of Mathlib, and above we import the necessary Mathlib modules
which contain (perhaps transitively through imports) the definitions and theorems we need.

-/

namespace Space

/-!

## A. Derivatives of functions on `Space d`

-/

/-- Given a function `f : Space d ‚Üí M` the derivative of `f` in direction `Œº`. -/
noncomputable def deriv {M d} [AddCommGroup M] [Module ‚Ñù M] [TopologicalSpace M]
    (Œº : Fin d) (f : Space d ‚Üí M) : Space d ‚Üí M :=
  (fun x => fderiv ‚Ñù f x (EuclideanSpace.single Œº (1:‚Ñù)))

@[inherit_doc deriv]
macro "‚àÇ[" i:term "]" : term => `(deriv $i)

/-!

###¬†A.1. Basic equalities

-/

lemma deriv_eq [AddCommGroup M] [Module ‚Ñù M] [TopologicalSpace M]
    (Œº : Fin d) (f : Space d ‚Üí M) (x : Space d) :
    deriv Œº f x = fderiv ‚Ñù f x (EuclideanSpace.single Œº (1:‚Ñù)) := by
  rfl

lemma deriv_eq_fderiv_basis [AddCommGroup M] [Module ‚Ñù M] [TopologicalSpace M]
    (Œº : Fin d) (f : Space d ‚Üí M) (x : Space d) :
    deriv Œº f x = fderiv ‚Ñù f x (basis Œº) := by
  rw [deriv_eq]
  congr 1
  funext i
  simp only [EuclideanSpace.single_apply, basis_apply]
  congr 1
  exact Lean.Grind.eq_congr' rfl rfl

/-!

###¬†A.2. Derivative of the constant function

-/

@[simp]
lemma deriv_const [NormedAddCommGroup M] [NormedSpace ‚Ñù M] (m : M) (Œº : Fin d) :
    deriv Œº (fun _ => m) t = 0 := by
  rw [deriv]
  simp



/-!

### A.3. Derivative distributes over addition

-/

/-- Derivatives on space distribute over addition. -/
lemma deriv_add [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (f1 f2 : Space d ‚Üí M) (hf1 : Differentiable ‚Ñù f1) (hf2 : Differentiable ‚Ñù f2) :
    ‚àÇ[u] (f1 + f2) = ‚àÇ[u] f1 + ‚àÇ[u] f2 := by
  unfold deriv
  simp only
  ext x
  rw [fderiv_add]
  rfl
  repeat fun_prop

/-- Derivatives on space distribute coordinate-wise over addition. -/
lemma deriv_coord_add (f1 f2 : Space d ‚Üí EuclideanSpace ‚Ñù (Fin d))
    (hf1 : Differentiable ‚Ñù f1) (hf2 : Differentiable ‚Ñù f2) :
    (‚àÇ[u] (fun x => f1 x i + f2 x i)) =
      (‚àÇ[u] (fun x => f1 x i)) + (‚àÇ[u] (fun x => f2 x i)) := by
  unfold deriv
  simp only
  ext x
  rw [fderiv_fun_add]
  simp only [ContinuousLinearMap.add_apply, Pi.add_apply]
  repeat fun_prop

/-!

### A.4. Derivative distributes over scalar multiplication

-/

/-- Scalar multiplication on space derivatives. -/
lemma deriv_smul [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (f : Space d ‚Üí M) (k : ‚Ñù) (hf : Differentiable ‚Ñù f) :
    ‚àÇ[u] (k ‚Ä¢ f) = (k ‚Ä¢ ‚àÇ[u] f) := by
  unfold deriv
  ext x
  rw [fderiv_const_smul]
  rfl
  fun_prop

/-- Coordinate-wise scalar multiplication on space derivatives. -/
lemma deriv_coord_smul (f : Space d ‚Üí EuclideanSpace ‚Ñù (Fin d)) (k : ‚Ñù)
    (hf : Differentiable ‚Ñù f) :
    ‚àÇ[u] (fun x => k * f x i) x= (k ‚Ä¢ ‚àÇ[u] (fun x => f x i)) x:= by
  unfold deriv
  rw [fderiv_const_mul]
  simp only [ContinuousLinearMap.coe_smul', Pi.smul_apply, smul_eq_mul]
  fun_prop

/-!

### A.5. Two spatial derivatives commute

-/

/-- Derivatives on space commute with one another. -/
lemma deriv_commute [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (f : Space d ‚Üí M) (hf : ContDiff ‚Ñù 2 f) : ‚àÇ[u] (‚àÇ[v] f) = ‚àÇ[v] (‚àÇ[u] f) := by
  unfold deriv
  ext x
  rw [fderiv_clm_apply, fderiv_clm_apply]
  simp only [fderiv_fun_const, Pi.ofNat_apply, ContinuousLinearMap.comp_zero, zero_add,
    ContinuousLinearMap.flip_apply]
  rw [IsSymmSndFDerivAt.eq]
  apply ContDiffAt.isSymmSndFDerivAt
  exact ContDiff.contDiffAt hf
  simp only [minSmoothness_of_isRCLikeNormedField, le_refl]
  repeat fun_prop

/-!

### A.6. Derivative of a component

-/

@[simp]
lemma deriv_component_same (Œº : Fin d) (x : Space d) :
    ‚àÇ[Œº] (fun x => x Œº) x = 1 := by
  conv_lhs =>
    enter [2, x]
    rw [‚Üê Space.coord_apply Œº x]
  change deriv Œº (Space.coordCLM Œº) x = 1
  simp only [deriv_eq, ContinuousLinearMap.fderiv]
  simp [Space.coordCLM, Space.coord]

lemma deriv_component_diff (Œº ŒΩ : Fin d) (x : Space d) (h : Œº ‚â† ŒΩ) :
    (deriv Œº (fun x => x ŒΩ) x) = 0 := by
  conv_lhs =>
    enter [2, x]
    rw [‚Üê Space.coord_apply _ x]
  change deriv Œº (Space.coordCLM ŒΩ) x = 0
  simp only [deriv_eq, ContinuousLinearMap.fderiv]
  simpa [Space.coordCLM, Space.coord] using h.symm

lemma deriv_component (Œº ŒΩ : Fin d) (x : Space d) :
    (deriv ŒΩ (fun x => x Œº) x) = if ŒΩ = Œº then 1 else 0 := by
  by_cases h' : ŒΩ = Œº
  ¬∑ subst h'
    simp
  ¬∑ rw [deriv_component_diff ŒΩ Œº]
    simp only [right_eq_ite_iff, zero_ne_one, imp_false]
    simpa using h'
    simpa using h'

/-!

### A.7. Derivative of a component squared

-/

lemma deriv_component_sq {d : ‚Ñï} {ŒΩ Œº : Fin d} (x : Space d) :
    (deriv ŒΩ (fun x => (x Œº) ^ 2) x) = if ŒΩ = Œº then 2 * x Œº else 0:= by
  rw [deriv_eq_fderiv_basis]
  rw [fderiv_pow]
  simp only [Nat.add_one_sub_one, pow_one, nsmul_eq_mul, Nat.cast_ofNat,
    ContinuousLinearMap.coe_smul', Pi.smul_apply, smul_eq_mul]
  rw [‚Üê deriv_eq_fderiv_basis, deriv_component]
  simp only [mul_ite, mul_one, mul_zero]
  fun_prop

/-!

### A.8. Derivivatives of components

-/

lemma deriv_euclid {d ŒΩ Œº} {f : Space d ‚Üí EuclideanSpace ‚Ñù (Fin n)}
    (hf : Differentiable ‚Ñù f) (x : Space d) :
    deriv ŒΩ (fun x => f x Œº) x = deriv ŒΩ (fun x => f x) x Œº := by
  rw [deriv_eq_fderiv_basis]
  change fderiv ‚Ñù (EuclideanSpace.proj Œº ‚àò fun x => f x) x (basis ŒΩ) = _
  rw [fderiv_comp]
  ¬∑ simp
    rw [‚Üê deriv_eq_fderiv_basis]
  ¬∑ fun_prop
  ¬∑ fun_prop

lemma deriv_lorentz_vector {d ŒΩ Œº} {f : Space d ‚Üí Lorentz.Vector d}
    (hf : Differentiable ‚Ñù f) (x : Space d) :
    deriv ŒΩ (fun x => f x Œº) x = deriv ŒΩ (fun x => f x) x Œº := by
  rw [deriv_eq_fderiv_basis]
  change fderiv ‚Ñù (Lorentz.Vector.coordCLM Œº ‚àò fun x => f x) x (basis ŒΩ) = _
  rw [fderiv_comp]
  ¬∑ simp
    rw [‚Üê deriv_eq_fderiv_basis]
    rfl
  ¬∑ fun_prop
  ¬∑ fun_prop

/-!

### A.9. Derivative of a norm squared

-/

/-!

#### A.9.1. Differentiability of the norm squared function

-/
@[fun_prop]
lemma norm_sq_differentiable : Differentiable ‚Ñù (fun x : Space d => ‚Äñx‚Äñ ^ 2) := by
  simp [@PiLp.norm_sq_eq_of_L2]
  fun_prop

/-!

#### A.9.2. Derivative of the norm squared function

-/

lemma deriv_norm_sq (x : Space d) (i : Fin d) :
    deriv i (fun x => ‚Äñx‚Äñ ^ 2) x = 2 * x i := by
  simp [@PiLp.norm_sq_eq_of_L2]
  rw [deriv_eq_fderiv_basis]
  rw [fderiv_fun_sum]
  simp only [ContinuousLinearMap.coe_sum', Finset.sum_apply]
  conv_lhs =>
    enter [2, j]
    rw [‚Üê deriv_eq_fderiv_basis]
    simp
  simp [deriv_component_sq]
  intro i hi
  fun_prop

/-!

### A.9. Derivative of the inner product

-/

open InnerProductSpace

/-!

#### A.10.1. Differentiability of the inner product function

-/

/-- The inner product is differentiable. -/
lemma inner_differentiable {d : ‚Ñï} :
    Differentiable ‚Ñù (fun y : Space d => ‚ü™y, y‚ü´_‚Ñù) := by
  simp only [PiLp.inner_apply, RCLike.inner_apply, conj_trivial]
  fun_prop

/-!

#### A.10.2. Derivative of the inner product function

-/

lemma deriv_eq_inner_self (x : Space d) (i : Fin d) :
    deriv i (fun x => ‚ü™x, x‚ü´_‚Ñù) x = 2 * x i := by
  convert deriv_norm_sq x i
  exact real_inner_self_eq_norm_sq _

/-!

### A.11. Differentiability of derivatives

-/

lemma deriv_differentiable {M} [NormedAddCommGroup M]
    [NormedSpace ‚Ñù M] {d : ‚Ñï} {f : Space d ‚Üí M}
    (hf : ContDiff ‚Ñù 2 f) (i : Fin d) :
    Differentiable ‚Ñù (deriv i f) := by
  have h1 : Differentiable ‚Ñù (fun x => fderiv ‚Ñù f x (basis i)) := by
    fun_prop
  convert h1 using 1
  funext x
  rw [deriv_eq_fderiv_basis]



/-!

## B. Derivatives of distributions on `Space d`

-/

open Distribution SchwartzMap

/-!

### B.1. The definition

-/
/-- Given a distribution (function) `f : Space d ‚Üíd[‚Ñù] M` the derivative
  of `f` in direction `Œº`. -/
noncomputable def distDeriv {M d} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (Œº : Fin d) : ((Space d) ‚Üíd[‚Ñù] M) ‚Üí‚Çó[‚Ñù] (Space d) ‚Üíd[‚Ñù] M where
  toFun f :=
    let ev : (Space d ‚ÜíL[‚Ñù] M) ‚ÜíL[‚Ñù] M := {
      toFun v := v (basis Œº)
      map_add' v1 v2 := by
        simp only [ContinuousLinearMap.add_apply]
      map_smul' a v := by
        simp
    }
    ev.comp (Distribution.fderivD ‚Ñù f)
  map_add' f1 f2 := by
    simp
  map_smul' a f := by simp


/-!

### B.2. Basic equality

-/

lemma distDeriv_apply {M d} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (Œº : Fin d) (f : (Space d) ‚Üíd[‚Ñù] M) (Œµ : ùì¢(Space d, ‚Ñù)) :
    (distDeriv Œº f) Œµ = fderivD ‚Ñù f Œµ (basis Œº) := by
  simp [distDeriv, Distribution.fderivD]


/-!

### B.3. Commutation of derivatives

-/

lemma schwartMap_fderiv_comm { d}
    (Œº ŒΩ : Fin d) (x : Space d) (Œ∑ : ùì¢(Space d, ‚Ñù)) :
    ((SchwartzMap.evalCLM (ùïú := ‚Ñù) (basis Œº))
      ((fderivCLM ‚Ñù) ((SchwartzMap.evalCLM (ùïú := ‚Ñù) (basis ŒΩ)) ((fderivCLM ‚Ñù) Œ∑)))) x =
    ((SchwartzMap.evalCLM (ùïú := ‚Ñù) (basis ŒΩ))
      ((fderivCLM ‚Ñù) ((SchwartzMap.evalCLM (ùïú := ‚Ñù) (basis Œº)) ((fderivCLM ‚Ñù) Œ∑)))) x := by
  have h1 := Œ∑.smooth
  have h2 := h1 2
  change fderiv ‚Ñù (fun x => fderiv ‚Ñù Œ∑ x (basis ŒΩ)) x (basis Œº) =
    fderiv ‚Ñù (fun x => fderiv ‚Ñù Œ∑ x (basis Œº)) x (basis ŒΩ)
  rw [fderiv_clm_apply, fderiv_clm_apply]
  simp only [fderiv_fun_const, Pi.ofNat_apply, ContinuousLinearMap.comp_zero, zero_add,
    ContinuousLinearMap.flip_apply]
  rw [IsSymmSndFDerivAt.eq]
  apply ContDiffAt.isSymmSndFDerivAt (n := 2)
  ¬∑ refine ContDiff.contDiffAt ?_
    exact h2
  ¬∑ simp
  ¬∑ fun_prop
  ¬∑ exact differentiableAt_const (basis Œº)
  ¬∑ fun_prop
  ¬∑ exact differentiableAt_const (basis ŒΩ)

lemma distDeriv_commute {M d} [NormedAddCommGroup M] [NormedSpace ‚Ñù M]
    (Œº ŒΩ : Fin d) (f : (Space d) ‚Üíd[‚Ñù] M) :
    (distDeriv ŒΩ (distDeriv Œº f)) = (distDeriv Œº (distDeriv ŒΩ f)) := by
  ext Œ∑
  simp [distDeriv, Distribution.fderivD]
  congr 1
  ext x
  rw [schwartMap_fderiv_comm Œº ŒΩ x Œ∑]

end Space
