/-
Copyright (c) 2025 Joseph Tooby-Smith. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Tooby-Smith
-/
import PhysLean.StringTheory.FTheory.SU5U1.Potential.ReducedCharges
/-!

# The irreducible subsets of charges for a present term

For a given `CodimensionOneConfig`, `I`, and a `PotentialTerm`, `T`,
we define the finite set of `T.ChargeType` such that a
`T.reducedChargesIsPresent I` is present if it contains a subset in this list.

We define this finite set of irreducible subsets of charges both in an
simple form ` presentIrredSetExe I T` which has the disavantage of being
slow to use `decide` with, and an explicit form `presentIrredSetExe I T`
which is faster to use `decide` with.

-/
namespace FTheory

namespace SU5U1
variable {I : CodimensionOneConfig}

namespace PotentialTerm

open CodimensionOneConfig

/-- For a `I : CodimensionOneConfig` and a `T : PotentialTerm`, the irreducible
  elements in `T.ChargeType` which if one occurs as a subset of
  `x : T.ChargeType` then `x` permits the term `T`.
  They are irreducible in the sense that they can't be broken down into smaller subsets which
  are also lead to the term `T`.

  The result `presentIrredSet` is an explicit version of these irreducible elements.
  -/
def presentIrredSetExe (I : CodimensionOneConfig) (T : PotentialTerm) : Finset T.ChargeType :=
  (T.reducedChargesIsPresent I).filter (fun x =>
    ∀ y ∈ (T.reducedChargesIsPresent I), x = y ∨ ¬ (y ⊆ x))

/-- OfNat instance on `Option ℤ`. -/
local instance (n : ℕ) : OfNat (Option ℤ) n where
  ofNat := some n

/-- Negation on `Option ℤ`. -/
local instance : Neg (Option ℤ) where
  neg x := match x with
    | none => none
    | some n => some (-n)

/-- For a `I = same` and a `T : PotentialTerm`, the irreducible
  elements in `T.ChargeType` which if one occurs as a subset of
  `x : T.ChargeType` then `x` permits the term `T`.
  They are irreducible in the sense that they can't be broken down into smaller subsets which
  are also lead to the term. -/
def presentIrredSetSame : (T : PotentialTerm) → Finset T.ChargeType
  | μ => {(-3, -3), (-2, -2), (-1, -1), (0, 0), (1, 1), (2, 2), (3, 3)}
  | K2 => {(-3, 0, {3}), (-3, 1, {2}), (-3, 2, {1}), (-3, 3, {0}), (-2, -1, {3}),
    (-2, 0, {2}), (-2, 1, {1}), (-2, 2, {0}), (-2, 3, {-1}), (-1, -2, {3}), (-1, -1, {2}),
    (-1, 0, {1}), (-1, 1, {0}), (-1, 2, {-1}), (-1, 3, {-2}), (0, -3, {3}), (0, -2, {2}),
    (0, -1, {1}), (0, 0, {0}), (0, 1, {-1}), (0, 2, {-2}), (0, 3, {-3}), (1, -3, {2}),
    (1, -2, {1}), (1, -1, {0}), (1, 0, {-1}), (1, 1, {-2}), (1, 2, {-3}), (2, -3, {1}),
    (2, -2, {0}), (2, -1, {-1}), (2, 0, {-2}), (2, 1, {-3}), (3, -3, {0}), (3, -2, {-1}),
    (3, -1, {-2}), (3, 0, {-3})}
  | K1 => {({-3}, {-2, -1}), ({-3}, {-3, 0}), ({-2}, {-1}), ({-2}, {-2, 0}), ({-2}, {-3, 1}),
    ({-1}, {-1, 0}), ({-1}, {-2, 1}), ({-1}, {-3, 2}), ({0}, {0}), ({0}, {-1, 1}), ({0}, {-2, 2}),
    ({0}, {-3, 3}), ({1}, {0, 1}), ({1}, {-1, 2}), ({1}, {-2, 3}), ({2}, {1}), ({2}, {0, 2}),
    ({2}, {-1, 3}), ({3}, {1, 2}), ({3}, {0, 3})}
  | W4 => {(-3, -3, {-3}), (-3, -2, {-1}), (-3, -1, {1}), (-3, 0, {3}), (-2, -2, {-2}),
    (-2, -1, {0}), (-2, 0, {2}), (-1, -2, {-3}), (-1, -1, {-1}), (-1, 0, {1}), (-1, 1, {3}),
    (0, -1, {-2}), (0, 0, {0}), (0, 1, {2}), (1, -1, {-3}), (1, 0, {-1}), (1, 1, {1}), (1, 2, {3}),
    (2, 0, {-2}), (2, 1, {0}), (2, 2, {2}), (3, 0, {-3}), (3, 1, {-1}), (3, 2, {1}), (3, 3, {3})}
  | W3 => {(-3, {-3}), (-2, {-2}), (-2, {-3, -1}), (-1, {-1}), (-1, {-2, 0}), (-1, {-3, 1}),
    (0, {0}), (0, {-1, 1}), (0, {-2, 2}), (0, {-3, 3}), (1, {1}), (1, {0, 2}), (1, {-1, 3}),
    (2, {2}), (2, {1, 3}), (3, {3})}
  | W2 => {(-3, {1}), (-3, {-1, 2}), (-3, {-3, 3}), (-3, {0, 3}), (-3, {-2, 2, 3}),
    (-2, {0, 1}), (-2, {-2, 2}), (-2, {0, 2}), (-2, {-1, 1, 2}), (-2, {-1, 0, 3}),
    (-2, {-2, 1, 3}), (-2, {-3, 2, 3}), (-1, {-1, 1}), (-1, {0, 1}), (-1, {-3, 2}),
    (-1, {-1, 0, 2}), (-1, {-2, 1, 2}), (-1, {-1, 3}), (-1, {-2, 0, 3}), (-1, {-3, 1, 3}),
    (0, {0}), (0, {-2, 1}), (0, {-1, 2}), (0, {-3, 1, 2}), (0, {-2, -1, 3}), (1, {-1, 0}),
    (1, {-3, 1}), (1, {-1, 1}), (1, {-2, 0, 1}), (1, {-2, -1, 2}), (1, {-3, 0, 2}), (1, {-2, 3}),
    (1, {-3, -1, 3}), (2, {-2, 0}), (2, {-1, 0}), (2, {-2, -1, 1}), (2, {-3, 0, 1}), (2, {-2, 2}),
    (2, {-3, -1, 2}), (2, {-3, -2, 3}), (3, {-1}), (3, {-3, 0}), (3, {-2, 1}), (3, {-3, -2, 2}),
    (3, {-3, 3})}
  | W1 => {({-3}, {1}), ({-3}, {-1, 2}), ({-3}, {-3, 3}), ({-3}, {0, 3}), ({-3}, {-2, 2, 3}),
    ({-2}, {0, 1}), ({-2}, {-2, 2}), ({-2}, {0, 2}), ({-2}, {-1, 1, 2}), ({-2}, {-1, 0, 3}),
    ({-2}, {-2, 1, 3}), ({-2}, {-3, 2, 3}), ({-1}, {-1, 1}), ({-1}, {0, 1}), ({-1}, {-3, 2}),
    ({-1}, {-1, 0, 2}), ({-1}, {-2, 1, 2}), ({-1}, {-1, 3}), ({-1}, {-2, 0, 3}), ({-1}, {-3, 1, 3}),
    ({0}, {0}), ({0}, {-2, 1}), ({0}, {-1, 2}), ({0}, {-3, 1, 2}), ({0}, {-2, -1, 3}),
    ({1}, {-1, 0}), ({1}, {-3, 1}), ({1}, {-1, 1}), ({1}, {-2, 0, 1}), ({1}, {-2, -1, 2}),
    ({1}, {-3, 0, 2}), ({1}, {-2, 3}), ({1}, {-3, -1, 3}), ({2}, {-2, 0}), ({2}, {-1, 0}),
    ({2}, {-2, -1, 1}), ({2}, {-3, 0, 1}), ({2}, {-2, 2}), ({2}, {-3, -1, 2}), ({2}, {-3, -2, 3}),
    ({3}, {-1}), ({3}, {-3, 0}), ({3}, {-2, 1}), ({3}, {-3, -2, 2}), ({3}, {-3, 3})}
  | Λ => {({-1}, {2}), ({-2, -1}, {3}), ({0}, {0}), ({-3, 0}, {3}), ({-2, 0}, {2}),
    ({-1, 0}, {1}), ({1}, {-2}), ({-3, 1}, {2}), ({-2, 1}, {1}), ({-1, 1}, {0}), ({0, 1}, {-1}),
    ({-3, 2}, {1}), ({-2, 2}, {0}), ({-1, 2}, {-1}), ({0, 2}, {-2}), ({1, 2}, {-3}), ({-3, 3}, {0}),
    ({-2, 3}, {-1}), ({-1, 3}, {-2}), ({0, 3}, {-3})}
  | β => {(-3, {-3}), (-2, {-2}), (-1, {-1}), (0, {0}), (1, {1}), (2, {2}), (3, {3})}
  | topYukawa => {(-3, {-2, -1}), (-3, {-3, 0}), (-2, {-1}), (-2, {-2, 0}), (-2, {-3, 1}),
    (-1, {-1, 0}), (-1, {-2, 1}), (-1, {-3, 2}), (0, {0}), (0, {-1, 1}), (0, {-2, 2}), (0, {-3, 3}),
    (1, {0, 1}), (1, {-1, 2}), (1, {-2, 3}), (2, {1}), (2, {0, 2}), (2, {-1, 3}), (3, {1, 2}),
    (3, {0, 3})}
  | bottomYukawa => {(-3, {0}, {3}), (-3, {1}, {2}), (-3, {2}, {1}), (-3, {3}, {0}),
    (-2, {-1}, {3}), (-2, {0}, {2}), (-2, {1}, {1}), (-2, {2}, {0}), (-2, {3}, {-1}),
    (-1, {-2}, {3}), (-1, {-1}, {2}), (-1, {0}, {1}), (-1, {1}, {0}), (-1, {2}, {-1}),
    (-1, {3}, {-2}), (0, {-3}, {3}), (0, {-2}, {2}), (0, {-1}, {1}), (0, {0}, {0}), (0, {1}, {-1}),
    (0, {2}, {-2}), (0, {3}, {-3}), (1, {-3}, {2}), (1, {-2}, {1}), (1, {-1}, {0}), (1, {0}, {-1}),
    (1, {1}, {-2}), (1, {2}, {-3}), (2, {-3}, {1}), (2, {-2}, {0}), (2, {-1}, {-1}), (2, {0}, {-2}),
    (2, {1}, {-3}), (3, {-3}, {0}), (3, {-2}, {-1}), (3, {-1}, {-2}), (3, {0}, {-3})}

-- #eval (presentSubsetExe .nextToNearestNeighbor bottomYukawa)
/-- For a `I = nearestNeighbor` and a `T : PotentialTerm`, the irreducible
  elements in `T.ChargeType` which if one occurs as a subset of
  `x : T.ChargeType` then `x` permits the term `T`.
  They are irreducible in the sense that they can't be broken down into smaller subsets which
  are also lead to the term `T`. -/
def presentIrredSetNN : (T : PotentialTerm) → Finset T.ChargeType
  | μ => {(-14, -14), (-9, -9), (-4, -4), (1, 1), (6, 6), (11, 11)}
  | K2 => {(-14, 1, {13}), (-14, 6, {8}), (-14, 11, {3}), (-9, -4, {13}),
    (-9, 1, {8}), (-9, 6, {3}), (-9, 11, {-2}), (-4, -9, {13}), (-4, -4, {8}), (-4, 1, {3}),
    (-4, 6, {-2}), (-4, 11, {-7}), (1, -14, {13}), (1, -9, {8}), (1, -4, {3}), (1, 1, {-2}),
    (1, 6, {-7}), (1, 11, {-12}), (6, -14, {8}), (6, -9, {3}), (6, -4, {-2}), (6, 1, {-7}),
    (6, 6, {-12}), (11, -14, {3}), (11, -9, {-2}), (11, -4, {-7}), (11, 1, {-12})}
  | K1 => {({-14}, {-7}), ({-14}, {-12, -2}), ({-9}, {-7, -2}), ({-9}, {-12, 3}),
    ({-4}, {-2}), ({-4}, {-7, 3}), ({-4}, {-12, 8}), ({1}, {-2, 3}), ({1}, {-7, 8}),
    ({1}, {-12, 13}), ({6}, {3}), ({6}, {-2, 8}), ({6}, {-7, 13}), ({11}, {3, 8}),
    ({11}, {-2, 13})}
  | W4 => {(-14, -14, {-14}), (-14, -9, {-4}), (-14, -4, {6}), (-9, -9, {-9}),
    (-9, -4, {1}), (-9, 1, {11}), (-4, -9, {-14}), (-4, -4, {-4}), (-4, 1, {6}), (1, -4, {-9}),
    (1, 1, {1}), (1, 6, {11}), (6, -4, {-14}), (6, 1, {-4}), (6, 6, {6}), (11, 1, {-9}),
    (11, 6, {1}), (11, 11, {11})}
  | W3 => {(-14, {-14}), (-9, {-9}), (-9, {-14, -4}), (-4, {-4}), (-4, {-9, 1}),
    (-4, {-14, 6}), (1, {1}), (1, {-4, 6}), (1, {-9, 11}), (6, {6}), (6, {1, 11}), (11, {11})}
  | W2 => {(-14, {-2, 8}), (-14, {3, 8}), (-14, {-12, 13}), (-14, {-2, 3, 13}),
    (-14, {-7, 8, 13}), (-9, {3}), (-9, {-7, 8}), (-9, {-2, 13}), (-9, {-12, 8, 13}), (-4, {-2, 3}),
    (-4, {-12, 8}), (-4, {-2, 8}), (-4, {-7, 3, 8}), (-4, {-7, -2, 13}), (-4, {-12, 3, 13}),
    (1, {-7, 3}), (1, {-2, 3}), (1, {-7, -2, 8}), (1, {-12, 3, 8}), (1, {-7, 13}),
    (1, {-12, -2, 13}), (6, {-2}), (6, {-12, 3}), (6, {-7, 8}), (6, {-12, -7, 13}), (11, {-7, -2}),
    (11, {-7, 3}), (11, {-12, -2, 3}), (11, {-12, -7, 8}), (11, {-12, 13})}
  | W1 => {({-14}, {-2, 8}), ({-14}, {3, 8}), ({-14}, {-12, 13}),
    ({-14}, {-2, 3, 13}), ({-14}, {-7, 8, 13}), ({-9}, {3}), ({-9}, {-7, 8}), ({-9}, {-2, 13}),
    ({-9}, {-12, 8, 13}), ({-4}, {-2, 3}), ({-4}, {-12, 8}), ({-4}, {-2, 8}), ({-4}, {-7, 3, 8}),
    ({-4}, {-7, -2, 13}), ({-4}, {-12, 3, 13}), ({1}, {-7, 3}), ({1}, {-2, 3}), ({1}, {-7, -2, 8}),
    ({1}, {-12, 3, 8}), ({1}, {-7, 13}), ({1}, {-12, -2, 13}), ({6}, {-2}), ({6}, {-12, 3}),
    ({6}, {-7, 8}), ({6}, {-12, -7, 13}), ({11}, {-7, -2}), ({11}, {-7, 3}), ({11}, {-12, -2, 3}),
    ({11}, {-12, -7, 8}), ({11}, {-12, 13})}
  | Λ => {({-4}, {8}), ({-9, -4}, {13}), ({1}, {-2}), ({-14, 1}, {13}),
    ({-9, 1}, {8}), ({-4, 1}, {3}), ({6}, {-12}), ({-14, 6}, {8}), ({-9, 6}, {3}), ({-4, 6}, {-2}),
    ({1, 6}, {-7}), ({-14, 11}, {3}), ({-9, 11}, {-2}), ({-4, 11}, {-7}), ({1, 11}, {-12})}
  | β => {(-14, {-14}), (-9, {-9}), (-4, {-4}), (1, {1}), (6, {6}), (11, {11})}
  | topYukawa => {(-14, {-7}), (-14, {-12, -2}), (-9, {-7, -2}), (-9, {-12, 3}),
    (-4, {-2}), (-4, {-7, 3}), (-4, {-12, 8}), (1, {-2, 3}), (1, {-7, 8}), (1, {-12, 13}), (6, {3}),
    (6, {-2, 8}), (6, {-7, 13}), (11, {3, 8}), (11, {-2, 13})}
  | bottomYukawa => {(-14, {1}, {13}), (-14, {6}, {8}), (-14, {11}, {3}),
    (-9, {-4}, {13}), (-9, {1}, {8}), (-9, {6}, {3}), (-9, {11}, {-2}), (-4, {-9}, {13}),
    (-4, {-4}, {8}), (-4, {1}, {3}), (-4, {6}, {-2}), (-4, {11}, {-7}), (1, {-14}, {13}),
    (1, {-9}, {8}), (1, {-4}, {3}), (1, {1}, {-2}), (1, {6}, {-7}), (1, {11}, {-12}),
    (6, {-14}, {8}), (6, {-9}, {3}), (6, {-4}, {-2}), (6, {1}, {-7}), (6, {6}, {-12}),
    (11, {-14}, {3}), (11, {-9}, {-2}), (11, {-4}, {-7}), (11, {1}, {-12})}

/-- For a `I = nextToNearestNeighbor` and a `T : PotentialTerm`, the irreducible
  elements in `T.ChargeType` which if one occurs as a subset of
  `x : T.ChargeType` then `x` permits the term `T`.
  They are irreducible in the sense that they can't be broken down into smaller subsets which
  are also lead to the term `T`. -/
def presentIrredSetNToNN : (T : PotentialTerm) → Finset T.ChargeType
  | μ => {(-13, -13), (-8, -8), (-3, -3), (2, 2), (7, 7), (12, 12)}
  | K2 => {(-13, 2, {11}), (-13, 7, {6}), (-13, 12, {1}), (-8, -3, {11}),
    (-8, 2, {6}), (-8, 7, {1}), (-8, 12, {-4}), (-3, -8, {11}), (-3, -3, {6}), (-3, 2, {1}),
    (-3, 7, {-4}), (-3, 12, {-9}), (2, -13, {11}), (2, -8, {6}), (2, -3, {1}), (2, 2, {-4}),
    (2, 7, {-9}), (7, -13, {6}), (7, -8, {1}), (7, -3, {-4}), (7, 2, {-9}), (12, -13, {1}),
    (12, -8, {-4}), (12, -3, {-9})}
  | K1 => {({-13}, {-9, -4}), ({-8}, {-4}), ({-8}, {-9, 1}),
    ({-3}, {-4, 1}), ({-3}, {-9, 6}), ({2}, {1}), ({2}, {-4, 6}), ({2}, {-9, 11}), ({7}, {1, 6}),
    ({7}, {-4, 11}), ({12}, {6}), ({12}, {1, 11})}
  | W4 => {(-13, -13, {-13}), (-13, -8, {-3}), (-13, -3, {7}),
    (-8, -8, {-8}), (-8, -3, {2}), (-8, 2, {12}), (-3, -8, {-13}), (-3, -3, {-3}), (-3, 2, {7}),
    (2, -3, {-8}), (2, 2, {2}), (2, 7, {12}), (7, -3, {-13}), (7, 2, {-3}), (7, 7, {7}),
    (12, 2, {-8}), (12, 7, {2}), (12, 12, {12})}
  | W3 => {(-13, {-13}), (-8, {-8}), (-8, {-13, -3}), (-3, {-3}),
    (-3, {-8, 2}), (-3, {-13, 7}), (2, {2}), (2, {-3, 7}), (2, {-8, 12}), (7, {7}),
    (7, {2, 12}), (12, {12})}
  | W2 => {(-13, {1, 6}), (-13, {-9, 11}), (-13, {1, 11}),
    (-13, {-4, 6, 11}), (-8, {-4, 6}), (-8, {1, 6}), (-8, {-4, 1, 11}), (-8, {-9, 6, 11}),
    (-3, {1}), (-3, {-9, 6}), (-3, {-4, 11}), (2, {-4, 1}), (2, {-4, 6}), (2, {-9, 1, 6}),
    (2, {-9, -4, 11}), (7, {-9, 1}), (7, {-4, 1}), (7, {-9, -4, 6}), (7, {-9, 11}), (12, {-4}),
    (12, {-9, 6})}
  | W1 => {({-13}, {1, 6}), ({-13}, {-9, 11}), ({-13}, {1, 11}),
    ({-13}, {-4, 6, 11}), ({-8}, {-4, 6}), ({-8}, {1, 6}), ({-8}, {-4, 1, 11}), ({-8}, {-9, 6, 11}),
    ({-3}, {1}), ({-3}, {-9, 6}), ({-3}, {-4, 11}), ({2}, {-4, 1}), ({2}, {-4, 6}),
    ({2}, {-9, 1, 6}), ({2}, {-9, -4, 11}), ({7}, {-9, 1}), ({7}, {-4, 1}), ({7}, {-9, -4, 6}),
    ({7}, {-9, 11}), ({12}, {-4}), ({12}, {-9, 6})}
  | Λ => {({-3}, {6}), ({-8, -3}, {11}), ({2}, {-4}), ({-13, 2}, {11}),
    ({-8, 2}, {6}), ({-3, 2}, {1}), ({-13, 7}, {6}), ({-8, 7}, {1}), ({-3, 7}, {-4}),
    ({2, 7}, {-9}), ({-13, 12}, {1}), ({-8, 12}, {-4}), ({-3, 12}, {-9})}
  | β => {(-13, {-13}), (-8, {-8}), (-3, {-3}), (2, {2}), (7, {7}),
    (12, {12})}
  | topYukawa => {(-13, {-9, -4}), (-8, {-4}), (-8, {-9, 1}), (-3, {-4, 1}),
    (-3, {-9, 6}), (2, {1}), (2, {-4, 6}), (2, {-9, 11}), (7, {1, 6}), (7, {-4, 11}), (12, {6}),
    (12, {1, 11})}
  | bottomYukawa => {(-13, {2}, {11}), (-13, {7}, {6}), (-13, {12}, {1}),
    (-8, {-3}, {11}), (-8, {2}, {6}), (-8, {7}, {1}), (-8, {12}, {-4}), (-3, {-8}, {11}),
    (-3, {-3}, {6}), (-3, {2}, {1}), (-3, {7}, {-4}), (-3, {12}, {-9}), (2, {-13}, {11}),
    (2, {-8}, {6}), (2, {-3}, {1}), (2, {2}, {-4}), (2, {7}, {-9}), (7, {-13}, {6}), (7, {-8}, {1}),
    (7, {-3}, {-4}), (7, {2}, {-9}), (12, {-13}, {1}), (12, {-8}, {-4}), (12, {-3}, {-9})}

/-- For a `I : CodimensionOneConfig` and a `T : PotentialTerm`, the irreducible
  elements in `T.ChargeType` which if one occurs as a subset of
  `x : T.ChargeType` then `x` permits the term `T`.
  They are irreducible in the sense that they can't be broken down into smaller subsets which
  are also lead to the term `T`. -/
def presentIrredSet: (I : CodimensionOneConfig) → (T : PotentialTerm) → Finset T.ChargeType
  | same, T => presentIrredSetSame T
  | nearestNeighbor, T => presentIrredSetNN T
  | nextToNearestNeighbor, T => presentIrredSetNToNN T

set_option maxRecDepth 2000 in
lemma isPresent_of_mem_presentIrredSet
    {I : CodimensionOneConfig} {T : PotentialTerm} (x : T.ChargeType)
    (h : x ∈ presentIrredSet I T) : IsPresent T x := by
  revert x
  revert T I
  decide

end PotentialTerm
end SU5U1
end FTheory
